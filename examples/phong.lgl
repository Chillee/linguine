// WebGL reference:
// http://www.mathematik.uni-marburg.de/~thormae/lectures/graphics1/code/WebGLShaderLightMat/ShaderLightMat.html
// Note that some varying values are baked in differently here (e.g. vNormal is just given to us)
// Also using Braid example as a reference
// https://capra.cs.cornell.edu/braid/dingus/#example=phong

tag modelPos is vec3;
tag model is vec4;
tag worldPos is vec3;
tag world is vec4;
tag cameraPos is vec3;
tag camera is vec4;
tag color is vec3;
tag alphaColor is vec4;

modelPos vPosition = [0., 0., 0.]:modelPos;
modelPos vNormal = [0., 0., 0.]:modelPos;
worldPos uLight = [1., 1., 1.]:worldPos;
model->world uModel = [
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.]
]:model->world;
world->camera uView = [
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.]
]:world->camera;

modelPos->model extendModel = [
  [1., 0., 0.],
  [0., 1., 0.],
  [0., 0., 1.],
  [0., 0., 0.]
]:modelPos->model;
model modelScale = [0., 0., 0., 1.]:model;
model->modelPos collapseModel = [ 
  [1., 0., 0., 0.],
  [0., 1., 0., 0.], 
  [0., 0., 1., 0.]
]:model->modelPos;

worldPos->world extendWorld = [
  [1., 0., 0.],
  [0., 1., 0.],
  [0., 0., 1.],
  [0., 0., 0.]
]:worldPos->world;
world worldScale = [0., 0., 0., 1.]:world;
world->worldPos collapseWorld = [ 
  [1., 0., 0., 0.],
  [0., 1., 0., 0.], 
  [0., 0., 1., 0.]
]:world->worldPos;

color->alphaColor extendColor = [
  [1., 0., 0.],
  [0., 1., 0.],
  [0., 0., 1.],
  [0., 0., 0.]
]:color->alphaColor;
alphaColor opaque = [0., 0., 0., 1.]:alphaColor;

vec4 getW = [0., 0., 0., 1.]:vec4;

color diffuse = [1., 0., 0.]:color;
color spec = [1.0, 0.0, 0.0]:color;

world vertH = uModel * ((extendModel * vPosition) + modelScale);
worldPos vert = (collapseWorld * vertH) / (dot vertH getW);

worldPos light = norm(uLight - vert);
//direction negLight = [0., 0., 0.]:direction - light;
// See glsl reflect definition
//direction reflected = negLight - (2. * (dot vNormal negLight) * vNormal);

//direction view = norm([0., 0., 0.]:position - vert);

//float lambertian = 0.0;
//float lDot = dot light vNormal;
//bool lDotCheck = (0. <= lDot);
//if (lDotCheck) { lambertian = lDot; } else { skip; }
//float specular = 0.0;
//bool lCheck = (0.0 <= lambertian && !(lambertian == 0.0));

//if(lCheck) {
//  float specAngle = 0.;
//  float specDot = dot reflected view;
//  bool specCheck = (0. <= specDot);
//  if (specCheck) { specAngle = specDot; } else { skip; }
//  specular = specAngle * specAngle * specAngle * specAngle;
//}
//else { skip; }

//color fragColor = lambertian * diffuse + specular * spec;
//alphaColor gl_FragColor = (extendColor * fragColor) + opaque;
//print gl_FragColor;