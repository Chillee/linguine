// GLSL reference:
// https://learnopengl.com/Lighting/Basic-Lighting
// Note that some varying values are baked in differently here (e.g. vNormal vs. normalWorld)
// Thus we sometimes use Braid example as a reference
// https://capra.cs.cornell.edu/braid/dingus/#example=phong

tag model is vec3;
tag modelHom is vec4;
tag world is vec3;
tag worldHom is vec4;
tag camera is vec3;
tag cameraHom is vec4;
tag color is vec3;
tag alphaColor is vec4;

model vPosition = [0., 0., 0.]:model;
model vNormal = [0., 0., 0.]:model;
world uLight = [1., 1., 1.]:world;
world uCameraPosition = [0., 0., 0.]:world;
modelHom->worldHom uModel = [
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.]
]:modelHom->worldHom;
worldHom->cameraHom uView = [
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.]
]:worldHom->cameraHom;

model->modelHom extendModel = [
  [1., 0., 0.],
  [0., 1., 0.],
  [0., 0., 1.],
  [0., 0., 0.]
]:model->modelHom;
modelHom modelScale = [0., 0., 0., 1.]:modelHom;
modelHom->model collapseModel = [ 
  [1., 0., 0., 0.],
  [0., 1., 0., 0.], 
  [0., 0., 1., 0.]
]:modelHom->model;

world->worldHom extendWorld = [
  [1., 0., 0.],
  [0., 1., 0.],
  [0., 0., 1.],
  [0., 0., 0.]
]:world->worldHom;
worldHom worldScale = [0., 0., 0., 1.]:worldHom;
worldHom->world collapseWorld = [ 
  [1., 0., 0., 0.],
  [0., 1., 0., 0.], 
  [0., 0., 1., 0.]
]:worldHom->world;

camera->cameraHom extendCamera = [
  [1., 0., 0.],
  [0., 1., 0.],
  [0., 0., 1.],
  [0., 0., 0.]
]:camera->cameraHom;
cameraHom cameraScale = [0., 0., 0., 1.]:cameraHom;
cameraHom->camera collapseCamera = [ 
  [1., 0., 0., 0.],
  [0., 1., 0., 0.], 
  [0., 0., 1., 0.]
]:cameraHom->camera;

color->alphaColor extendColor = [
  [1., 0., 0.],
  [0., 1., 0.],
  [0., 0., 1.],
  [0., 0., 0.]
]:color->alphaColor;
alphaColor opaque = [0., 0., 0., 1.]:alphaColor;

worldHom getWorldW = [0., 0., 0., 1.]:worldHom;

model->color modelAsColor = [
  [1., 0., 0.],
  [0., 1., 0.],
  [0., 0., 1.]
]:model->color;

world->color worldAsColor = [
  [1., 0., 0.],
  [0., 1., 0.],
  [0., 0., 1.]
]:world->color;

color ambient = [.3, 0., 0.]:color;
color diffuse = [.3, 0.0, 0.0]:color;
color spec = [1.0, 1.0, 1.0]:color;

world worldPosition = collapseWorld * (uModel * ((extendModel * vPosition) + modelScale));
world lightDir = norm(uLight - worldPosition);
world worldNormal = norm(collapseWorld * (uModel * (extendModel * vNormal)));

float lambertian = 0.0;
float lDot = dot lightDir worldNormal;
bool lDotCheck = (0. <= lDot);
if (lDotCheck) { lambertian = lDot; } else { skip; }

bool lCheck = (0.0 <= lambertian && !(lambertian == 0.0));
world viewDir = norm(uCameraPosition - worldPosition);
world negLight = [0., 0., 0.]:world - lightDir;
//See glsl reflection definition
world reflectDir = negLight - (2. * (dot worldNormal negLight) * worldNormal);
float specular = 0.0;

if(lCheck) {
  float specAngle = 0.;
  float specDot = dot viewDir reflectDir;
  bool specDotCheck = (0. <= specDot);
  if (specDotCheck) { specAngle = specDot; } else { skip; }
  specular = specAngle * specAngle * specAngle * specAngle * specAngle * specAngle * specAngle * specAngle;
}
else { skip; }

color fragColor = ambient + lambertian * diffuse + specular * spec;
alphaColor gl_FragColor = (extendColor * fragColor) + opaque;
print gl_FragColor;