\newcount\draft\draft=1 % set to 0 for submission or publication
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsthm,amssymb,bbm,amsfonts,syntax}
\usepackage[ligature, inference]{semantic}
\usepackage[T1]{fontenc}
\usepackage{mathpartir}
\usepackage{nccmath}
\usepackage{xxx}

\begin{document}
\newcommand{\mat}{\mathsf{mat}_{n_1{\times}n_2}}
\newcommand{\vv}[1]{\mathsf{vec}_{#1}}
\newcommand{\env}[1]{#1,\sigma}
\newcommand{\defas}{\mathrel{::=}}
\newenvironment{leftalign}%
    {\fleqn[5pt]\csname align*\endcsname}%
    {\csname endalign*\endcsname\endfleqn}
\newcommand{\alt}{\:|\:}

\mathlig{->}{\rightarrow}
\mathlig{|-}{\vdash}
\mathlig{=>}{\Rightarrow}
\mathligson

\title{Matrix Tagging Syntax and Semantics}
\author{Dietrich Geisler and Irene Yoon}

\section{Syntax}

Literals in our language can be scalar numbers, vectors, or matrices:
%
\begin{leftalign}
s &\in \mathbb{R} \\
v &\defas [s_1,s_2,\dots] \\
m &\defas [[s_{11},s_{12},\dots],[s_{21},s_{22},\dots],\dots]
\end{leftalign}
%
Expressions can be variables, literals (with tags as defined below), or operators:
%
\begin{leftalign}
x &\in \text{variables} \\
c &\defas s \alt m \alt v \alt () \\
e &\defas \cdots \alt
    s \alt
    () \alt
    \tau\;x:=e \alt
    v:\mu \alt
    m:\mu_1->\mu_2 \alt
    e_1+e_2 \alt
    e_1*e_2 \alt
    e_1\;\mathsf{.*}\;e_2
\end{leftalign}
\xxx{What's in that $\cdots$ in the expression syntax?}
%
The \textsf{.*} operator represents elementwise multiplication (whereas $*$ is proper linear algebra multiplication).
Our type system consists of user-defined \emph{tags}, $T$, alongside built-in types:
%
\begin{leftalign}
n &\in \mathbb{N} \\
T &\in \text{tags} \\
\mu &\defas \mat \alt
    \vv{n} \alt T \\
\tau &\defas \mathsf{unit} \alt
    \mathsf{scalar} \alt
    \mu \alt
    \mu_1->\mu_2
\end{leftalign}
%
Function types $\mu_1 -> \mu_2$ are not ordinary functions; they are matrices used to map from one vector space to another using matrix--vector multiplication.

\section{Subtype Ordering}

We define a judgment $\tau_1 \leq \tau_2$ for subtyping on ordinary types.
Subtyping is reflexive and transitive, as usual:
%
\begin{mathpar}
\inferrule
    { }
    {\tau\leq\tau}

\inferrule
    {\tau_1 \leq \tau_2 \and \tau_2 \leq \tau_3}
    {\tau_1 \leq \tau_3}
\end{mathpar}
%
The null type \textsf{unit} acts as a top type:
%
\begin{mathpar}
\inferrule
    { }
    {\tau\leq\mathsf{unit}}
\end{mathpar}
%
We want to use vectors and $1 \times n$ matrices interchangeably:
%
\begin{mathpar}
\inferrule
    { }
    {\vv{n}\leq\mathsf{mat}_{1{\times}n}}

\inferrule
    { }
    {\mathsf{mat}_{1{\times}n}\leq\vv{n}}
\end{mathpar}

We also introduce a second partial order on tags, of the form $\Delta |- \mu_1 \leq_\Delta \mu_2$.  This ordering refers to a context $\Delta$, which is a map from tags $T$ to matrix types $\mu$:
%
\begin{mathpar}
\inferrule
    {\Delta|-\Delta(\mu_1)=\mu_2}
    {\Delta|-\mu_1\leq_\Delta \mu_2}
\end{mathpar}
%
This relation has the usual reflexivity and transitivity properties:
%
\begin{mathpar}
\inferrule
    { }
    {\Delta|-\mu\leq_\Delta \mu}

\inferrule
    {\Delta|-\mu_1 \leq_\Delta \mu_2 \and \Delta|-\mu_2 \leq_\Delta \mu_3}
    {\Delta|-\mu_1 \leq_\Delta \mu_3}
\end{mathpar}
%
Vectors have a top type representing general vectors of dimension $n$ as $\vv{n}$.  Similarly, we can give the top type of transformation matrices, whose type is always given by $\mu_1->\mu_2$, to be $\mat$:
%
\begin{mathpar}
\inferrule
    {\Delta|-\mu_1\leq_\Delta\vv{n_1}\qquad\Delta|-\mu_2\leq_\Delta\vv{n_2}}
    {\Delta|-\mu_1->\mu_2\leq_\Delta\mat}
\end{mathpar}
%
The function-like transformation matrix types, $\mu_1 -> \mu_2$, have the same standard subtyping relationship as ordinary function types:
%
\begin{mathpar}
\inferrule
	{\Delta|-\mu_1'\leq_\Delta \mu_1\qquad\Delta|-\mu_2\leq_\Delta \mu_2'}
	{\mu_1\leq_\Delta \mu_1'->\mu_2'}
\end{mathpar}

\section{Static Semantics}

This typing judgement is a map from an expression to the type of that expression under some variable context $\Gamma$, from variable names to types, and some tag context $\Delta$ defined above.

\subsection{Subsumption}
Any type in a given context can be cast ``up'' at any time.
%
\begin{mathpar}
\inferrule
	{\tau_1\leq\tau_2\qquad\Gamma,\Delta|-e:\tau_1,\Gamma}
	{\Gamma,\Delta|-e:\tau_2,\Gamma}

\inferrule
	{\Delta|-\mu_1\leq_\Delta \mu_2\qquad\Gamma,\Delta|-e:\mu_1,\Gamma}
	{\Gamma,\Delta|-e:\mu_2,\Gamma}
\end{mathpar}

\subsection{Constants and Variable Declarations}
Declaring constants produce the types one would expect:
%
\begin{mathpar}
\inferrule
	{ }
	{\Gamma,\Delta|-():\mathsf{unit},\Gamma}

\inferrule
	{ }
	{\Gamma,\Delta|-s:\mathsf{scalar},\Gamma}
\end{mathpar}

When declaring vectors and matrices, we must provide a tag, causing a tagged value to produce the appropriate type.
%
\begin{mathpar}
\inferrule
	{\mu\leq_\Delta\vv{n}}
	{\Gamma,\Delta|-(v:\mu):\mu,\Gamma}

\inferrule
	{\mu_1\leq_\Delta\vv{n_1}\qquad\mu_2\leq_\Delta\vv{n_2}}
	{\Gamma,\Delta|-(m:\mu_1->\mu_2):\mu_1->\mu_2,\Gamma}
\end{mathpar}

Declaring variables requires an immediate assignment -- as a result, there is no mutation in this language.
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e:\tau,\Gamma'}
	{\Gamma,\Delta|-\tau\;x:=e:\mathsf{unit},\Gamma'(x):=\tau}
\end{mathpar}

\subsection{Binary Operations}

All operators on scalars work as one might expect.

Types are closed under addition and scalar multiplication
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e_1:\tau,\Gamma'\qquad\Gamma',\Delta|-e_2:\tau,\Gamma''}
	{\Gamma,\Delta|-e_1+e_2:\tau,\Gamma''}

\inferrule
	{\Gamma,\Delta|-e_1:\tau_1\qquad\Gamma,\Delta|-e_2:\mathsf{scalar}\qquad\tau_1\leq_\Delta\mat\qquad}
	{\Gamma,\Delta|-e_1*e_2:\tau_1}
\end{mathpar}

Component multiplication can be defined as a mathematical operation, but makes little formal sense.  Such operations are allowed, but don't interact with spaces and tags and result in a complete lack of information about a resulting matrix.
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e_1:\mat,\Gamma'\qquad\Gamma',\Delta|-e_2:\mat,\Gamma''}
	{\Gamma,\Delta|-e_1\;\mathsf{.*}\;e_2:\mat,\Gamma''}
\end{mathpar}

Matrix multiplication is both a way of transforming from one tag to another and for composing two matrix functions together.
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e_1:\tau_1,\Gamma'\qquad\Gamma',\Delta|-e_2:\tau_1->\tau_2,\Gamma''}
	{\Gamma,\Delta|-e_1*e_2:\tau_2,\Gamma''}

\inferrule
	{\Gamma,\Delta|-e_1:\tau_1->\tau_2,\Gamma'\qquad\Gamma',\Delta|-e_2:\tau_2->\tau_3,\Gamma''}
	{\Gamma,\Delta|-\;e_1*e_2:\tau_1->\tau_3,\Gamma''}

\inferrule
	{\Gamma,\Delta|-e_1:\mat,\Gamma'\qquad\Gamma',\Delta|-e_2:\mathsf{mat}_{n_2{\times}n_3},\Gamma''}
	{\Gamma,\Delta|-\;e_1*e_2:\mathsf{mat}_{n_1{\times}n_3},\Gamma''}
\end{mathpar}

\section{Dynamic Semantics}

The operational semantics of this language map, in a single step, from a command to a constant and a state $\sigma$.  $\sigma$ itself is, as usual, a map from variable names to constants.

\subsection{Substitution}
Substitutions work as expected on the environment $\sigma$.
%
\begin{mathpar}
\inferrule
	{ }
	{\env{\tau\;x:=c}->(),\sigma[c/x]}

\inferrule
	{\env{e}->\env{e'}}
	{\env{\tau\;x:=e}->\env{\tau\;x:=e'}}
\end{mathpar}

Type annotations are just thrown out at an operational level:
%
\begin{mathpar}
\inferrule
	{ }
	{\env{v:\tau}->\env{v}}

\inferrule
	{ }
	{\env{m:\tau}->\env{m}}
\end{mathpar}

\subsection{Mathematical Operations}
As usual, we can reduce on either side of the mathematical operations $\odot\in\{+,*,\mathsf{.*}\}$
%
\begin{mathpar}
\inferrule
	{\env{e_1}->\env{e_1'}}
	{\env{e_1\odot e_2}->\env{e_1'\odot e_2}}

\inferrule
	{\env{e_2}->\env{e_2'}}
	{\env{c\odot e_2}->\env{c\odot e_2'}}
\end{mathpar}

Addition and scalar multiplication have standard mathematical meaning.  Similarly, vector and matrix multiplication have standard mathematical meaning.  Component-wise multiplication is identical to matrix addition, except using multiplication of numbers in place of addition of numbers.  For readability, formal semantics of each of these operations will be ommitted.
\end{document}
