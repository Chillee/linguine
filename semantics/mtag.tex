\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsthm,amssymb,bbm,amsfonts,syntax}
\usepackage[ligature, inference]{semantic}
\usepackage[T1]{fontenc}
\usepackage{mathpartir}
\textwidth 7.0 truein
\oddsidemargin -0.25in %left-hand edge
\evensidemargin -0.5 truein %right-hand edge
\topmargin -0.85in %top of paper to top of head, pulls whole unit
\textheight 9.5in
\setlength\parindent{0pt}
\setlength{\parskip}{.5em}

\begin{document}
\newcommand{\mat}{\mathsf{mat}_{n_1{\times}n_2}}
\newcommand{\vv}[1]{\mathsf{vec}_{#1}}
\newcommand{\env}[1]{#1,\sigma}

\mathlig{->}{\rightarrow}
\mathlig{|-}{\vdash}
\mathlig{=>}{\Rightarrow}
\mathligson

\title{Matrix Tagging Syntax and Semantics}
\author{Dietrich Geisler and Irene Yoon}

\section{Syntax}

$\begin{array}{rcl}
T &\in& \text{tags} \\
x &\in& \text{variables} \\
n &\in& \mathbb{N} \\
s &\in& \mathbb{R}\\
m &::=& [[s_{11},s_{12},\dots],[s_{21},s_{22},\dots],\dots] \\
v &::=& [s_1,s_2,\dots] \\
\tau&::=&\mathsf{unit}\;|\;\mathsf{scalar}\;|\; \mat \;|\;\vv{n}\;|\;T\;|\;\tau_1->\tau_2\\
c&::=&s\;|\;m\;|\;v\;|\;()\\
e&::=&\dots\;|\;c\;|\;\tau\;x:=e\;|\;m:\tau\;|\;v:\tau\;|\;e_1+e_2\;|\;e_1*e_2\;|\;e_1\;\mathsf{.*}\;e_2
\end{array}$

\section{Subtype Ordering}

% Including some English-language context for rules is important.
We define a judgment $\tau_1 \leq \tau_2$ for subtyping.
Subtyping is reflexive and transitive, as usual:
\begin{mathpar}
\inferrule
    { }
    {\tau\leq\tau}

\inferrule
    {\tau_1 \leq \tau_2 \and \tau_2 \leq \tau_3}
    {\tau_1 \leq \tau_3}
\end{mathpar}

Here are some rules for subtyping on base types:
%
\begin{mathpar}
\inferrule
    { }
    {\tau\leq\mathsf{unit}}

\inferrule
    { }
    {\mathsf{int}\leq\mathsf{scalar}}

\inferrule
    { }
    {\vv{n}\leq\mathsf{mat}_{1{\times}n}}

\inferrule
    { }
    {\mathsf{mat}_{1{\times}n}\leq\vv{n}}
\end{mathpar}

We also introduce another partial ordering for tags $\leq_\Delta$ with reflexivity and transitivity:

\begin{mathpar}
\inferrule
    { }
    {\Delta|-\tau\leq_\Delta\tau}

\inferrule
    {\Delta|-\tau_1 \leq_\Delta \tau_2 \and \Delta|-\tau_2 \leq_\Delta \tau_3}
    {\Delta|-\tau_1 \leq_\Delta \tau_3}
\end{mathpar}

This rule refers to some context $\Delta$:
%
\begin{mathpar}
\inferrule
    {\Delta|-\Delta(\tau_1)=\tau_2}
    {\Delta|-\tau_1\leq_\Delta\tau_2}
\end{mathpar}

This rule lets us treat transformation matrices, whose type is always given by $\tau_1 \rightarrow \tau_2$ where $\tau_1$ and $\tau_2$ are members of $\Delta$, as matrices:
%
\begin{mathpar}
\inferrule
    {\Delta|-\tau_1\leq_\Delta\vv{n_1}\qquad\Delta|-\tau_2\leq_\Delta\vv{n_2}}
    {\Delta|-\tau_1->\tau_2\leq_\Delta\mat}
\end{mathpar}


\section{Static Semantics}

\subsection{Subsumption}
Any type in a given context can be cast ``up'' at any time.
%
\begin{mathpar}
\inferrule
	{\tau_1\leq\tau_2\qquad\Gamma,\Delta|-e:\tau_1}
	{\Gamma,\Delta|-e:\tau_2}

\inferrule
	{\Delta|-\tau_1\leq_\Delta\tau_2\qquad\Gamma,\Delta|-e:\tau_1}
	{\Gamma,\Delta|-e:\tau_2}
\end{mathpar}

We also have standard subsumption for functions under $\Delta$:
%
\begin{mathpar}
\inferrule
	{\Delta|-\tau_1\leq_\Delta\tau_1'\qquad\Delta|-\tau_2\leq_\Delta\tau_2'\qquad\Gamma,\Delta|-e:\tau_1'->\tau_2}
	{\Gamma,\Delta|-e:\tau_1->\tau_2'}
\end{mathpar}

\subsection{Constants and Variable Declarations}
Declaring constants produce the types one would expect:
%
\begin{mathpar}
\inferrule
	{ }
	{\Gamma,\Delta|-s:\mathsf{Scalar}}
\end{mathpar}

When declaring vectors and matrices, we must provide a tag, causing a tagged value to produce the appropriate type.
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-v:\vv{n}\qquad\tau\leq_\Delta\vv{n}}
	{\Gamma,\Delta|-(v:\tau):\tau}

\inferrule
	{\Gamma,\Delta|-m:\mat\qquad\tau\leq_\Delta\mat}
	{\Gamma,\Delta|-(m:\tau_1->\tau_2):\tau_1->\tau_2}
\end{mathpar}

Declaring variables requires an immediate assignment -- as a result, there is no mutation in this language.
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e:\tau}
	{\Gamma,\Delta,\tau\;x:=e|-\Gamma(x)=\tau}
\end{mathpar}

\subsection{Binary Operations}

All operators on Scalars and Ints work as one might expect (recall that $\mathsf{Int}\leq\mathsf{Scalar}$).

Tags and spaces are closed under addition and scalar multiplication
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e_1:\tau\qquad\Gamma,\Delta|-e_2:\tau}
	{\Gamma,\Delta|-e_1+e_2:\tau}

\inferrule
	{\Gamma,\Delta|-e_1:\tau_1\qquad\Gamma,\Delta|-e_2:\tau_2\qquad\tau_1\leq_\Delta\mat\qquad\tau_2\leq\mathsf{Scalar}}
	{\Gamma,\Delta|-e_1*e_2:\tau_1}
\end{mathpar}

Component multiplication can be defined as a mathematical operation, but makes little formal sense.  Such operations are allowed, but don't interact with spaces and tags and result in a complete lack of information about a resulting matrix.
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e_1:\tau\qquad\Gamma,\Delta|-e_2:\tau\qquad\tau\leq_\Delta\mat}
	{\Gamma,\Delta|-e_1\;\mathsf{.*}\;e_2:\mat}
\end{mathpar}

Matrix multiplication is both a way of transforming from one tag to another and for composing two matrix functions together.
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e_1:\tau_1\qquad\Gamma,\Delta|-e_2:\tau_1->\tau_2}
	{\Gamma,\Delta|-e_1*e_2:\tau_2}

\inferrule
	{\Gamma,\Delta|-e_1:\tau_1->\tau_2\qquad\Gamma,\Delta|-e_2:\tau_2->\tau_3}
	{\Gamma,\Delta|-\;e_1*e_2:\tau_1->\tau_3}
\end{mathpar}

\section{Dynamic Semantics}
Substitutions work as expected on the environment $\sigma$.
%
\begin{mathpar}
\inferrule
	{ }
	{\env{\tau\;x:=c}->\mathsf{skip},\sigma[c/x]}

\inferrule
	{\env{e}->\env{e'}}
	{\env{\tau\;x:=e}->\env{\tau\;x:=e'}}

\inferrule
	{ }
	{\env{\tau\;x:=(\tau)\;m}->\mathsf{skip},\sigma[m/x]}
\end{mathpar}

\subsection{Mathematical Operations}
As usual, we can reduce on either side of the mathematical operations $\odot\in\{+,*,\mathsf{.*}\}$
%
\begin{mathpar}
\inferrule
	{\env{e_1}->\env{e_1'}}
	{\env{e_1\odot e_2}->\env{e_1'\odot e_2}}

\inferrule
	{\env{e_2}->\env{e_2'}}
	{\env{c\odot e_2}->\env{c\odot e_2'}}
\end{mathpar}

Addition and scalar multiplication have standard mathematical meaning.  Similarly, vector and matrix multiplication have standard mathematical meaning.  Component-wise multiplication is identical to matrix addition, except using multiplication of numbers in place of addition of numbers.  For readability, formal semantics of each of these operations will be ommitted.
\end{document}
