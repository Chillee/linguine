\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsthm,amssymb,bbm,amsfonts,syntax}
\usepackage[ligature, inference]{semantic}
\usepackage[T1]{fontenc}
\usepackage{mathpartir}
\textwidth 7.0 truein
\oddsidemargin -0.25in %left-hand edge
\evensidemargin -0.5 truein %right-hand edge
\topmargin -0.85in %top of paper to top of head, pulls whole unit
\textheight 9.5in
\setlength\parindent{0pt}
\setlength{\parskip}{.5em}

\begin{document}
\newcommand{\mat}{\mathsf{mat}_{n_1{\times}n_2}}
\newcommand{\vv}[1]{\mathsf{vec}_{#1}}
\newcommand{\env}[1]{#1,\sigma}

\mathlig{->}{\rightarrow}
\mathlig{|-}{\vdash}
\mathlig{=>}{\Rightarrow}
\mathligson

\title{Matrix Tagging Syntax and Semantics}
\author{Dietrich Geisler and Irene Yoon}

\section{Syntax}

$\begin{array}{rcl}
x &\in& \text{variables} \\
n &\in& \mathbb{N} \\
s &\in& \mathbb{R}\\
T &\in& \text{tags}\\
v &::=& [s_1,s_2,\dots] \\
m &::=& [[s_{11},s_{12},\dots],[s_{21},s_{22},\dots],\dots] \\
\mu&::=& \mat \;|\;\vv{n}\;|\;T\\
\tau&::=&\mathsf{unit}\;|\;\mathsf{scalar}\;|\; \mu \;|\; \mu_1->\mu_2\\
c&::=&s\;|\;m\;|\;v\;|\;()\\
e&::=&\dots\;|\;s\;|\;()\;|\;\tau\;x:=e\;|\;v:\mu\;|\;m:\mu_1->\mu_2\;|\;e_1+e_2\;|\;e_1*e_2\;|\;e_1\;\mathsf{.*}\;e_2
\end{array}$

\section{Subtype Ordering}

% Including some English-language context for rules is important.
We define a judgment $\tau_1 \leq \tau_2$ for subtyping.
Subtyping is reflexive and transitive, as usual:
\begin{mathpar}
\inferrule
    { }
    {\tau\leq\tau}

\inferrule
    {\tau_1 \leq \tau_2 \and \tau_2 \leq \tau_3}
    {\tau_1 \leq \tau_3}
\end{mathpar}

Here are some rules for subtyping on base types.  Note that we want to use vectors and 1x$n$ matrices interchangeably:
%
\begin{mathpar}
\inferrule
    { }
    {\tau\leq\mathsf{unit}}

\inferrule
    { }
    {\vv{n}\leq\mathsf{mat}_{1{\times}n}}

\inferrule
    { }
    {\mathsf{mat}_{1{\times}n}\leq\vv{n}}
\end{mathpar}

We also introduce another partial ordering for tags $\mu_1\leq_\Delta \mu_2$.  This ordering refers to a context $\Delta$, which maps $T$ to $T$:
%
\begin{mathpar}
\inferrule
    {\Delta|-\Delta(\mu_1)=\mu_2}
    {\Delta|-\mu_1\leq_\Delta \mu_2}
\end{mathpar}

This rule has the usual reflexivity and transitivity
%
\begin{mathpar}
\inferrule
    { }
    {\Delta|-\mu\leq_\Delta \mu}

\inferrule
    {\Delta|-\mu_1 \leq_\Delta \mu_2 \and \Delta|-\mu_2 \leq_\Delta \mu_3}
    {\Delta|-\mu_1 \leq_\Delta \mu_3}
\end{mathpar}

Vectors have a top type representing general vectors of dimension $n$ as $\vv{n}$.  Similarly, we can give the top type of transformation matrices, whose type is always given by $\mu_1->\mu_2$, to be $\mat$:
%
\begin{mathpar}
\inferrule
    {\Delta|-\mu_1\leq_\Delta\vv{n_1}\qquad\Delta|-\mu_2\leq_\Delta\vv{n_2}}
    {\Delta|-\mu_1->\mu_2\leq_\Delta\mat}
\end{mathpar}

We also have standard partial order for functions under $\Delta$:
%
\begin{mathpar}
\inferrule
	{\Delta|-\mu_1'\leq_\Delta \mu_1\qquad\Delta|-\mu_2\leq_\Delta \mu_2'}
	{\mu_1\leq_\Delta \mu_1'->\mu_2'}
\end{mathpar}

\section{Static Semantics}

This typing judgement is a map from an expression to the type of that expression under some variable context $\Gamma$, from variable names to types, and some tag context $\Delta$ defined above.

\subsection{Subsumption}
Any type in a given context can be cast ``up'' at any time.
%
\begin{mathpar}
\inferrule
	{\tau_1\leq\tau_2\qquad\Gamma,\Delta|-e:\tau_1,\Gamma}
	{\Gamma,\Delta|-e:\tau_2,\Gamma}

\inferrule
	{\Delta|-\mu_1\leq_\Delta \mu_2\qquad\Gamma,\Delta|-e:\mu_1,\Gamma}
	{\Gamma,\Delta|-e:\mu_2,\Gamma}
\end{mathpar}

\subsection{Constants and Variable Declarations}
Declaring constants produce the types one would expect:
%
\begin{mathpar}
\inferrule
	{ }
	{\Gamma,\Delta|-():\mathsf{unit},\Gamma}

\inferrule
	{ }
	{\Gamma,\Delta|-s:\mathsf{scalar},\Gamma}
\end{mathpar}

When declaring vectors and matrices, we must provide a tag, causing a tagged value to produce the appropriate type.
%
\begin{mathpar}
\inferrule
	{\mu\leq_\Delta\vv{n}}
	{\Gamma,\Delta|-(v:\mu):\mu,\Gamma}

\inferrule
	{\mu_1\leq_\Delta\vv{n_1}\qquad\mu_2\leq_\Delta\vv{n_2}}
	{\Gamma,\Delta|-(m:\mu_1->\mu_2):\mu_1->\mu_2,\Gamma}
\end{mathpar}

Declaring variables requires an immediate assignment -- as a result, there is no mutation in this language.
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e:\tau,\Gamma'}
	{\Gamma,\Delta|-\tau\;x:=e:\mathsf{unit},\Gamma'(x):=\tau}
\end{mathpar}

\subsection{Binary Operations}

All operators on scalars work as one might expect.

Types are closed under addition and scalar multiplication
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e_1:\tau,\Gamma'\qquad\Gamma',\Delta|-e_2:\tau,\Gamma''}
	{\Gamma,\Delta|-e_1+e_2:\tau,\Gamma''}

\inferrule
	{\Gamma,\Delta|-e_1:\tau_1\qquad\Gamma,\Delta|-e_2:\mathsf{scalar}\qquad\tau_1\leq_\Delta\mat\qquad}
	{\Gamma,\Delta|-e_1*e_2:\tau_1}
\end{mathpar}

Component multiplication can be defined as a mathematical operation, but makes little formal sense.  Such operations are allowed, but don't interact with spaces and tags and result in a complete lack of information about a resulting matrix.
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e_1:\mat,\Gamma'\qquad\Gamma',\Delta|-e_2:\mat,\Gamma''}
	{\Gamma,\Delta|-e_1\;\mathsf{.*}\;e_2:\mat,\Gamma''}
\end{mathpar}

Matrix multiplication is both a way of transforming from one tag to another and for composing two matrix functions together.
%
\begin{mathpar}
\inferrule
	{\Gamma,\Delta|-e_1:\tau_1,\Gamma'\qquad\Gamma',\Delta|-e_2:\tau_1->\tau_2,\Gamma''}
	{\Gamma,\Delta|-e_1*e_2:\tau_2,\Gamma''}

\inferrule
	{\Gamma,\Delta|-e_1:\tau_1->\tau_2,\Gamma'\qquad\Gamma',\Delta|-e_2:\tau_2->\tau_3,\Gamma''}
	{\Gamma,\Delta|-\;e_1*e_2:\tau_1->\tau_3,\Gamma''}

\inferrule
	{\Gamma,\Delta|-e_1:\mat,\Gamma'\qquad\Gamma',\Delta|-e_2:\mathsf{mat}_{n_2{\times}n_3},\Gamma''}
	{\Gamma,\Delta|-\;e_1*e_2:\mathsf{mat}_{n_1{\times}n_3},\Gamma''}
\end{mathpar}

\section{Dynamic Semantics}

The operational semantics of this language map, in a single step, from a command to a constant and a state $\sigma$.  $\sigma$ itself is, as usual, a map from variable names to constants.

\subsection{Substitution}
Substitutions work as expected on the environment $\sigma$.
%
\begin{mathpar}
\inferrule
	{ }
	{\env{\tau\;x:=c}->(),\sigma[c/x]}

\inferrule
	{\env{e}->\env{e'}}
	{\env{\tau\;x:=e}->\env{\tau\;x:=e'}}
\end{mathpar}

Type annotations are just thrown out at an operational level:
%
\begin{mathpar}
\inferrule
	{ }
	{\env{v:\tau}->\env{v}}

\inferrule
	{ }
	{\env{m:\tau}->\env{m}}
\end{mathpar}

\subsection{Mathematical Operations}
As usual, we can reduce on either side of the mathematical operations $\odot\in\{+,*,\mathsf{.*}\}$
%
\begin{mathpar}
\inferrule
	{\env{e_1}->\env{e_1'}}
	{\env{e_1\odot e_2}->\env{e_1'\odot e_2}}

\inferrule
	{\env{e_2}->\env{e_2'}}
	{\env{c\odot e_2}->\env{c\odot e_2'}}
\end{mathpar}

Addition and scalar multiplication have standard mathematical meaning.  Similarly, vector and matrix multiplication have standard mathematical meaning.  Component-wise multiplication is identical to matrix addition, except using multiplication of numbers in place of addition of numbers.  For readability, formal semantics of each of these operations will be ommitted.
\end{document}
